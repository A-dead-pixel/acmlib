[ ] BRUTY
    [ ] maski bitowe: przejrzenie wszystkich podciągów 
    [ ] generowanie wszystkich ciągów n-elementowych
        [ ] generowanie wszystkich permutacji
    [ ] wyznaczanie ścieżki między dwoma wierzchołkami (graf/drzewo)
    [ ] skomplikowane backtracki

[ ] DEBUG 
    [ ] pisanie generatorek
        [ ] sprawdzarka w bashu 
        [ ] sprawdzarka w C++
        [ ] generowanie losowych liczb, permutacji, drzew, grafów skierowanych / nieskierowanych / spójnych / bez multikrawędzi
    [ ] wykrywanie błędów
        [ ] flagi kompilacji 
        [ ] czas wykonania programu oraz zużyta pamięć 
        [ ] używanie narzędzia gdb do wykrywania runtime error'ów 
        [ ] nagłówki 

[ ] GRAFY
    [ ] Drzewa 
        [ ] jump-pointery
            [ ] najniższy wspólny przodek (LCA)
            [ ] operacje na ścieżkach (np. otrzymanie maximum)
        [ ] właściwości numeracji wierzchołków w drzewie
            [ ] preorder, postorder, podobne 
        [ ] dynamiki na drzewie
        [ ] znane algorytmy: szukanie centroidów, średnicy drzewa
    [ ] Graf dwudzielny
        [ ] określanie dwudzielności grafu
        [ ] skojarzenia w grafach dwudzielnych 
        [ ] twierdzenie Halla 
        [ ] twierdzenie K\"{o}niga 
    [ ] Skierowany Graf Acykliczny (DAG)
        [ ] sortowanie topologiczne (toposort) 
        [ ] dynamiki na DAGach 
        [ ] podział na warstwy
    [ ] Grafy 
        [ ] DFS, BFS 
        [ ] drzewo DFS 
            [ ] funkcja low \& mosty, punkty artykulacji, dwuspójne 
        [ ] Dijkstra 
        [ ] rozbicie wierzchołkowe
        [ ] potęgowanie macierzy sąsiedztwa 
        [ ] silne spójne składowe (SCC) 
        [ ] cykl Eulera 
        [ ] minimalne drzewo rozpinające (MST)
            [ ] algorytm Kruskala (mniej ważny: algorytm Prima)  
            [ ] Prufer Code do brutowania wszystkich możliwych drzew 
        [ ] rozbicie wierzchołkowe 
        [ ] 2-SAT 
    [ ] Meduzy 
    [ ] Grafy planarne 
        [ ] wzór Eulera 
        [ ] zapytania o istnienie ścieżki w grafie planarnym 

[ ] STRUKTURY DANYCH
    [ ] Trie 
    [ ] Drzewa przedziałowe 
        [ ] drzewa przedział-przedział  
        [ ] drzewa trwałe, wskaźnikowe
    [ ] Sqrt 
        [ ] sqrt decomposition
        [ ] split \& rebuild
        [ ] algorytm mo 
    [ ] kolejka monotoniczna 
    [ ] mniejszy do większego
    [ ] find \& union 
    [ ] sumy prefixowe 
    [ ] std::vector jako stos, std::deque jako kolejka, std::set, std::map 
    [ ] sort
        [ ] std::sort, komparator i błędy z komparatorem
        [ ] sortowanie kubełkowe 
        [ ] skalowanie 

[ ] DYNAMIKI 
    [ ] problem plecakowy (różne odmiany, sqrt optymalizacja) 
    [ ] dynamiki kombinatoryczne 
    [ ] dynamiki przedziałowe 
    [ ] dynamiki optymalizacyjne 
    [ ] dynamiki wykładnicze 
    [ ] potęgowanie macierzy 

[ ] MATMA
    [ ] arytmetyka modulo
        [ ] najmniejszy wspólny dzielnik (NWD) 
            [ ] rozszerzony algorytm euklidesa, odwrotność modulo 
        [ ] funkcja Phi (totient Eulera) 
            [ ] Małe Twierdzenie Fermat 
        [ ] Chińskie Twierdzenie o Resztach 
        [ ] szybkie potęgowanie 
    [ ] znajdowanie dzielników (sqrt), dzielników pierwszych (sito Eratostenesa/sqrt) 
    [ ] teoria gier 
        [ ] twierdzenie Sprague-Grundy'ego 
    [ ] potęgowanie macierzy 
    [ ] podstawy kombinatoryki
        [ ] dwumian Newton'a
        [ ] zasada włączeń i wyłączeń

[ ] GEOMETRIA 
    [ ] iloczyn wektorowy 
    [ ] pole wielokąta 
    [ ] wielokąty wypukłe 
        [ ] otoczka wypukła 
    [ ] zamiatanie 
    [ ] sortowanie kątowe 
    [ ] geometria obliczeniowa 
    [ ] najbliższa para punktów 
    [ ] najdalsza para punktów

[ ] ALGORYTMY TEKSTOWE 
    [ ] liniowe algorytmy tekstowe 
        [ ] tablica pi, algorytm KMP  
        [ ] algorytm Manachera 
        [ ] tablica prefixo-prefixowa 
        [ ] szablony 
        [ ] okresy 
    [ ] hashowanie (posłów, podciągów, przypisanie literkom/liczbom losowe wagi i sprawdzanie sumy)
    [ ] drzewo Trie 
    [ ] tablica suffixowa 

[ ] OPTYMALIZACJE
    [ ] dziel i zwyciężaj 
        [ ] bardziej skomplikowane przykłady dziel i zwyciężaj
        [ ] meet in the middle 
    [ ] wyszukiwanie binarne 
        [ ] wyszukiwanie binarne po wyniku
        [ ] wyszukiwanie binarne wielu rzeczy na raz / równoległe wyszukiwanie binarne
    [ ] koszt zamortyzowany
        [ ] gąsienica 
        [ ] zadania na stos
    [ ] skalowanie 
    [ ] lider ciągu
    [ ] odpowiednie struktury danych
    [ ] bitsety
