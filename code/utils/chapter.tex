\chapter{Utils}

\myimport{headers}
\myrawimport[-l sh]{headers/bazshrc.sh}
\myrawimport[-l raw]{headers/vimrc}
\myrawimport[-l sh]{headers/sprawdzaczka.sh}
% \myimport{example-code}

\chapter{Podejścia}

\begin{itemize}[noitemsep]
	\item dynamik, zachłan
	\item sposób "liczba dobrych obiektów = liczba wszystkich obiektów - liczba złych obiektow"
	\item czy warunek konieczny = warunek wystarczający?
	\item odpowiednie przekształcenie równania
	\item zastanowić się nad łatwiejszym problemem, bez jakiegoś elementu z treści
	\item sprowadzić problem do innego, łatwiejszego/mniejszego problemu
	\item sprowadzić problem 2D do problemu 1D (zamiatanie; niezależność wyniku dla współrzędnych X od współrzędnych Y)
	\item konstrukcja grafu
	\item określenie struktury grafu
	\item optymalizacja bruta do wzorcówki
	\item czy można poprawić (może zachłannie) rozwiązanie nieoptymalne?
	\item czy są ciekawe fakty w rozwiązaniach optymalnych? (może się do tego przydać brute)
	\item sprawdzić czy w zadaniu czegoś jest "mało" (np. czy wynik jest mały, albo jakaś zmienna, może się do tego przydać brute)
	\item odpowiednio "wzbogacić" jakiś algorytm
	\item cokolwiek poniżej $10^9$ operacji ma szansę wejść
	\item co można wykonać offline? coś można posortować? coś można shuffle'ować?
	\item narysować dużo swoich własnych przykładów i coś z nich wywnioskować
	\item skupienie się na pozycji jakiegoś specjalnego elementu, np najmniejszego
	\item szacowanie wyniku - czy wynik jest mały? czy umiem skonstruować algorytm który zawsze znajdzie upper bound na wynik?
	\item sklepać brute który sprawdza obserwacje, zawsze jeśli potrzebujemy zoptymalizować dp, wypisać wartości na małym przykładzie
	\item pierwiastki - elementy $>$ i $<$ $\sqrt{N}$ osobno, rebuild co $\sqrt{N}$ operacji, jeśli suma wartości $=N$, jest $\sqrt{N}$ różnych wartości
	\item rozwiązania probabilistyczne, paradoks urodzeń
\end{itemize}
