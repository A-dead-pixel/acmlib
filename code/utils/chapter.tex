\chapter{Utils}

\myimport{headers}
\myrawimport[-l sh]{headers/.bashrc}
\myrawimport[-l raw]{headers/.vimrc}
\myrawimport[-l sh]{headers/sprawdzaczka.sh}
\myrawimport[-l sh]{headers/towrite.sh}
% \myimport{example-code}

\chapter{Podejścia}

\begin{itemize}[noitemsep]
	\item \textbf{Czytanie ze zrozumieniem}
	\item dynamik, zachłan
	\item dziel i zwyciężaj - matematyka dyskretna, $opt(i) \leq opt(i + 1)$
	\item sposób "liczba dobrych obiektów = liczba wszystkich obiektów - liczba złych obiektow"
	\item czy warunek konieczny = warunek wystarczający?
	\item odpowiednie przekształcenie równania; uniezależnienie funkcji od jakiejś zmiennej, zauważenie wypukłości
	\item zastanowić się nad łatwiejszym problemem, bez jakiegoś elementu z treści
	\item sprowadzić problem do innego, łatwiejszego/mniejszego problemu
	\item sprowadzić problem 2D do problemu 1D (zamiatanie; niezależność wyniku dla współrzędnych X od współrzędnych Y)
	\item konstrukcja grafu
	\item określenie struktury grafu
	\item optymalizacja bruta do wzorcówki
	\item czy można poprawić (może zachłannie) rozwiązanie nieoptymalne?
	\item czy są ciekawe fakty w rozwiązaniach optymalnych? (może się do tego przydać brute)
	\item sprawdzić czy w zadaniu czegoś jest "mało" (np. czy wynik jest mały, albo jakaś zmienna, może się do tego przydać brute)
	\item odpowiednio "wzbogacić" jakiś algorytm
	\item cokolwiek poniżej $10^9$ operacji ma szansę wejść
	\item co można wykonać offline? czy jest coś, czego kolejność nie ma znaczenia?
	\item co można posortować? czy jest zawsze jakaś pewna optymalna kolejność?
	\item narysować dużo swoich własnych przykładów i coś z nich wywnioskować
	\item skupienie się na pozycji jakiegoś specjalnego elementu, np najmniejszego
	\item szacowanie wyniku - czy wynik jest mały? czy umiem skonstruować algorytm który zawsze znajdzie upper bound na wynik?
	\item sklepać brute który sprawdza obserwacje, zawsze jeśli potrzebujemy zoptymalizować dp, wypisać wartości na małym przykładzie
	\item pierwiastki - elementy $>$ i $<$ $\sqrt{N}$ osobno, rebuild co $\sqrt{N}$ operacji, jeśli suma wartości $=N$, jest $\sqrt{N}$ różnych wartości
	\item rozwiązania probabilistyczne, paradoks urodzeń
	\item meet in the middle, backtrack
	\item sprowadzić stan do jednoznacznej postaci na podstawie podanych operacji, co pozwala sprawdzić czy z jednego stanu da się otrzymać drugi
\end{itemize}
